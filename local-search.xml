<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>连续线段</title>
    <link href="/2020/05/22/%E8%BF%9E%E7%BB%AD%E7%BA%BF%E6%AE%B5/"/>
    <url>/2020/05/22/%E8%BF%9E%E7%BB%AD%E7%BA%BF%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="连续线段"><a class="markdownIt-Anchor" href="#连续线段"></a> 连续线段</h1><p>##问题描述</p><p>平面上两个点（一个点由(x,y)坐标组成）可构成一个线段，两个线段如果有一个端点相同，则可构成一个连续线段。假设构成线段的两个端点为v1(x1,y1)和v2(x2,y2)，在此满足x1&lt;x2，其中v1称为线段的起点，v2为线段的终点。同样，对于连续线段来说，在此满足xi&lt;xi+1（i=1…n-1，n为连续线段中的端点数，xi为相应端点的X轴坐标）。输入一组线段（用两个端点的x、y坐标表示线段，线段个数大于等于2，小于等于100），编程计算出连续线段中包含最多线段数的线段，输出相应的线段数和起点位置（注意，不是最长的连续线段，是包含最多线段的连续线段）。例如：</p><p><img src="https://pics.images.ac.cn/image/5ec7c7151ce95.html" srcset="/img/loading.gif" alt="" /></p><p>上图中有10个线段，其中5、10、4号线段连成了一条连续线段，线段数3条，起点位置为5号线段的左端点；6、8、2、3、9号线段连成了另一条连续线段，该连续线段包含的线段数最多，为5条，起点位置是6号线段的左端点。<br />注意：<br />1）不考虑线段中间相交的情况；<br />2）不会有三条或三条以上的线段共一个端点；<br />3）只会出现一条包含最多线段的连续线段；</p><p>##输入形式</p><p>先从控制台输入线段数，然后从下一行开始分行输入各线段两个端点的x、y坐标，其中第一个端点的X轴坐标小于第二个端点的X轴坐标，即x1&lt;x2，x、y坐标都用整数表示，不会超过int的表示范围。各整数坐标值间以一个空格分隔。</p><p>##输出形式</p><p>先在控制台输出包含最多线段数的连续线段的线段数，然后输出连续线段的起点的x、y坐标，输出数据<strong>都以一个空格分隔</strong>。</p><p>##样例输入</p><p>10</p><p>80 75 125 75</p><p>60 40 80 55</p><p>80 55 90 20</p><p>140 120 195 205</p><p>10 111 70 165</p><p>22 35 43 43</p><p>22 175 80 205</p><p>43 43 60 40</p><p>90 20 125 60</p><p>70 165 140 120</p><p>##样例输出</p><p>5 22 35</p><p>##样例说明</p><p>输入了十个线段，第一个线段两个端点分别为(80,75）和(125,75），其它线段类似，如上图所示，这些线段所构成的连续线段中包含最多线段数的连续线段的线段数为5，起点为(22,35），所以输出：5 22 35。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加密文件1</title>
    <link href="/2020/05/22/%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B61/"/>
    <url>/2020/05/22/%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B61/</url>
    
    <content type="html"><![CDATA[<h1 id="加密文件"><a class="markdownIt-Anchor" href="#加密文件"></a> 加密文件</h1><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>有一种加密方法为：其使用一个字母串（可以含重复字母，字母个数不超过50）作为密钥。假定密钥单词串为feather，则先去掉密钥单词中的重复字母得到单词串feathr，然后再将字母表中的其它字母以反序追加到feathr的后面：</p><table><thead><tr><th>f</th><th>e</th><th>a</th><th>t</th><th>h</th><th>r</th><th>z</th><th style="text-align:left">y</th><th>x</th><th>w</th><th>v</th><th>u</th><th>s</th><th>q</th><th>p</th><th>o</th><th>n</th><th>m</th><th>l</th><th>k</th><th>j</th><th>i</th><th>g</th><th>d</th><th>c</th><th>b</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>加密字母的对应关系如下：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>k</th><th>l</th><th style="text-align:center">m</th><th>n</th><th>o</th><th>p</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>f</td><td>e</td><td>a</td><td>t</td><td>h</td><td>r</td><td>z</td><td>y</td><td>x</td><td>w</td><td>v</td><td>u</td><td style="text-align:center">s</td><td>q</td><td>p</td><td>o</td><td>n</td><td>m</td><td>l</td><td>k</td><td>j</td><td>i</td><td>g</td><td>d</td><td>c</td><td>b</td></tr></tbody></table><p>其中第一行为原始英文字母，第二行为对应加密字母。其它字符不进行加密。编写一个程序，用这种密码加密文件。假定要加密的文件名为encrypt.txt及加密后的文件名为output.txt，并假定输入文件中字母全为小写字母，并且输入密钥也全为小写字母。</p><h2 id="输入形式"><a class="markdownIt-Anchor" href="#输入形式"></a> 输入形式</h2><p>从标准输入中输入密钥串，并从文件encrypt.txt中读入要加密的内容。</p><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>加密后结果输出到文件output.txt中。</p><h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2><p>feather<br />和文件encrypt.txt中内容，例如被加密的文件encrypt.txt中内容为：<br />c language is wonderful.</p><h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2><p>加密后output.txt文件中内容为：<br />a ufqzjfzh xl gpqthmrju.</p><h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2><p>首先将给定的密钥单词去除重复字母，然后按照上面的加密对应表对encrypt.txt文件内容进行加密即可得到加密后的文件，其中只对英文字母进行加密对换，并且假设encrypt.txt中的英文字母全是小写字母。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key[<span class="hljs-number">52</span>])</span></span>&#123;    <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">52</span>];    <span class="hljs-keyword">int</span> alphabet[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;, i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; key[k] != <span class="hljs-string">'\0'</span>; k++)&#123;        <span class="hljs-keyword">if</span>(alphabet[key[k]-<span class="hljs-string">'a'</span>] == <span class="hljs-number">0</span>)&#123;            alphabet[key[k]-<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>;            tmp[i++] = key[k];        &#125;    &#125;    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">25</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;        <span class="hljs-keyword">if</span>(alphabet[j] == <span class="hljs-number">0</span>)&#123;            alphabet[j] = <span class="hljs-number">1</span>;            tmp[i++] = j + <span class="hljs-string">'a'</span>;        &#125;    &#125;    tmp[i] = <span class="hljs-string">'\0'</span>;    <span class="hljs-built_in">strcpy</span>(key, tmp);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> key[<span class="hljs-number">52</span>], c[LEN];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    gets(key);    convert(key);    FILE *<span class="hljs-literal">INPUT</span>, *<span class="hljs-literal">OUTPUT</span>;    <span class="hljs-literal">INPUT</span> = fopen(<span class="hljs-string">"encrypt.txt"</span>,<span class="hljs-string">"r"</span>);    <span class="hljs-literal">OUTPUT</span> = fopen(<span class="hljs-string">"output.txt"</span>,<span class="hljs-string">"w"</span>);    <span class="hljs-keyword">while</span>(fgets(c, LEN, <span class="hljs-literal">INPUT</span>))&#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(c); i++)&#123;            <span class="hljs-keyword">if</span>(c[i] &gt;= <span class="hljs-string">'a'</span> &amp;&amp; c[i] &lt;= <span class="hljs-string">'z'</span>)&#123;                fputc(key[c[i]-<span class="hljs-string">'a'</span>], <span class="hljs-literal">OUTPUT</span>);            &#125;            <span class="hljs-keyword">else</span>&#123;                fputc(c[i], <span class="hljs-literal">OUTPUT</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小型图书管理系统</title>
    <link href="/2020/03/14/%E5%B0%8F%E5%9E%8B%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/03/14/%E5%B0%8F%E5%9E%8B%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>##小型图书管理系统</p><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>小明同学特别喜欢买书看书。由于书较多，摆放杂乱，找起来非常麻烦。这学期小明同学上了数据结构与程序设计课后，决定改变这种状况：用C开发一个小型图书管理系统。系统中包含的图书信息有：书名、作者、出版社、出版日期等。首先，图书管理系统对已有的书（原始书库，存放在一个文本文件中）按书名字典序进行（排序）摆放（即将原始无序的图书信息文件生成一个有序的文件，即新书库），以便查找。该管理系统可以对新书库中图书条目进行如下操作：</p><ol><li>录入。新增书录入到书库中（即从输入中读入一条图书信息插入到已排序好的图书文件相关位置处）</li><li>查找。按书名或书名中关键字信息在书库中查找相关图书信息，若有多本书，按字典序输出。</li><li>删除。输入书名或书名中关键字信息，从书库中查找到相关书并将其删除，并更新书库。</li></ol><p>##输入形式</p><p>原始的图书信息（原始书库）保存在当前目录下的books.txt中。<br />用户操作从控制台读入，首先输入操作功能序号（1代表录入操作，2代表查找操作，3代表删除操作，0代表将已更新的图书信息保存到书库中并退出程序），然后在下一行输入相应的操作信息（录入操作后要输入一条图书信息，查找和删除操作后只要输入书名或书名中部分信息）。程序支行过程中可以进行多次操作，直到退出（输入操作0）程序。<br />要求：</p><ol><li>原始文件中的图书信息与录入的图书信息格式相同，每条图书信息都在一行上，包括书名（不超过50个字符）、作者（不超过20个字符）、出版社（不超过30个字符）和出版日期（不超过10个字符），只由英文字母和下划线组成，用一个空格分隔。图书信息总条数不会超过500.</li><li>下划线字符参加排序。</li><li>图书不会重名。</li></ol><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>进行录入和删除操作，系统会更新图书信息，但不会在控制台窗口显示任何信息。<br />进行查找操作后，将在控制台按书名字典序分行输出查找到的图书信息，书名占50个字符宽度，作者占20个字符宽度，出版社占30个字符宽度，出版日期占10个字符宽度，都靠左对齐输出。<br />最终按字典排序的图书信息保存在当前目录下的ordered.txt中，每条图书信息占一行，格式与查找输出的图书信息相同。</p><h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2><p><strong>假设books.txt中保存的原始图书信息为：</strong><br />The_C_programming_language Kernighan Prentice_Hall 1988<br />Programming_in_C Yin_Bao_Lin China_Machine_Press 2013<br />Data_structures_and_Algorithm_Analysis_in_C Mark_Allen_Weiss Addison_Wesley 1997<br />ANSI_and_ISO_Standard_c Plauger Microsoft_Press 1992<br />Data_structures_and_program_design_in_C Robert_Kruse Pearson_Education 1997<br />Computer_network_architectures Anton_Meijer Computer_Science_Press 1983<br />C_programming_guidelines Thomas_Plum Prentice_Hall 1984<br />Data_structures_using_C Tenenbaum Prentice_Hall 1990<br />Operating_system_concepts Peterson Addison_Wesley 1983<br />Computer_networks_and_internets Douglas_E_Come Electronic_Industry 2017<br /><strong>用户控制台输入信息为：</strong><br />1<br />Data_structures_and_C_programs Christopher Addison_Wesley 1988<br />2<br />structure<br />1<br />The_C_programming_tutor Leon_A_Wortman R_J_Brady 1984<br />2<br />rogram<br />3<br />rogramming<br />0</p><p>##样例输出</p><p><strong>用户输入“2 structure”后，控制台输出：</strong></p><p><img src="https://pics.images.ac.cn/image/5ec7c86e3cc25.html" srcset="/img/loading.gif" alt="" /></p><p><strong>用户输入“2 rogram”后，控制台输出：</strong></p><p><img src="https://pics.images.ac.cn/image/5ec7c8912f36e.html" srcset="/img/loading.gif" alt="" /></p><p><strong>ordered.txt文件内容为：</strong></p><p><img src="https://ae01.alicdn.com/kf/H1ca8ad7496bb4f89825a15365d4233bbv.jpg" srcset="/img/loading.gif" alt="" /></p><h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2><p>先读入books.txt中的10条图书信息，按照书名进行字典序排序；用户进行了五次操作，然后退出：第一次操作是插入了一条图书信息，这时有11条图书信息，按书名字典序排序为：<br />ANSI_and_ISO_Standard_c Plauger Microsoft_Press 1992<br />C_programming_guidelines Thomas_Plum Prentice_Hall 1984<br />Computer_network_architectures Anton_Meijer Computer_Science_Press 1983<br />Computer_networks_and_internets Douglas_E_Come Electronic_Industry 2017<br />Data_structures_and_Algorithm_Analysis_in_C Mark_Allen_Weiss Addison_Wesley 1997<br />Data_structures_and_C_programs Christopher Addison_Wesley 1988<br />Data_structures_and_program_design_in_C Robert_Kruse Pearson_Education 1997<br />Data_structures_using_C Tenenbaum Prentice_Hall 1990<br />Operating_system_concepts Peterson Addison_Wesley 1983<br />Programming_in_C Yin_Bao_Lin China_Machine_Press 2013<br />The_C_programming_language Kernighan Prentice_Hall 1988<br />第二次操作是查找书名包含structure的图书，有4本图书信息按照格式要求输出到屏幕；第三次操作又插入了一条图书信息，这时有12条图书信息；第四次操作查找书名包含rogram的图书，有6本图书信息按照格式要求输出到屏幕；第五次操作是删除书名包含rogramming的图书信息，有四条图书信息要删除，剩下八条图书信息；最后退出程序前将剩余的八条图书信息按照格式要求存储在ordered.txt文件中。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELEMENT 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">books</span> &#123;</span>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">51</span>];    <span class="hljs-keyword">char</span> author[<span class="hljs-number">21</span>];    <span class="hljs-keyword">char</span> <span class="hljs-built_in">press</span>[<span class="hljs-number">31</span>];    <span class="hljs-keyword">char</span> date[<span class="hljs-number">11</span>];&#125; BOOKS;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *p,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *q)</span> </span>&#123;    <span class="hljs-keyword">int</span> c;    c = <span class="hljs-built_in">strcmp</span>((*(BOOKS *) p).name, (*(BOOKS *) q).name);    <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> oprt = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">51</span>];    BOOKS book[ELEMENT];    FILE *IN, *OUT;    IN = fopen(<span class="hljs-string">"books.txt"</span>, <span class="hljs-string">"r"</span>);    OUT = fopen(<span class="hljs-string">"ordered.txt"</span>, <span class="hljs-string">"w"</span>);    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(IN, <span class="hljs-string">"%s %s %s %s"</span>, book[n].name, book[n].author, book[n].<span class="hljs-built_in">press</span>, book[n].date) != EOF) &#123;        n++;    &#125;    qsort(book, n, <span class="hljs-keyword">sizeof</span>(BOOKS), cmp);    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;oprt);        <span class="hljs-keyword">if</span> (oprt == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                <span class="hljs-built_in">fprintf</span>(OUT, <span class="hljs-string">"%-50s%-20s%-30s%-10s\n"</span>, book[i].name, book[i].author, book[i].<span class="hljs-built_in">press</span>, book[i].date);            &#125;            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oprt == <span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s %s %s %s"</span>, book[n].name, book[n].author, book[n].<span class="hljs-built_in">press</span>, book[n].date);            n++;            qsort(book, n, <span class="hljs-keyword">sizeof</span>(BOOKS), cmp);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oprt == <span class="hljs-number">2</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, str);            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(book[i].name, str)) &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%-50s%-20s%-30s%-10s\n"</span>, book[i].name, book[i].author, book[i].<span class="hljs-built_in">press</span>, book[i].date);                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oprt == <span class="hljs-number">3</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, str);            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(book[i].name, str)) &#123;                    n = n - <span class="hljs-number">1</span>;                    <span class="hljs-keyword">for</span> (j = i; j &lt; n; j++) &#123;                        book[j] = book[j + <span class="hljs-number">1</span>];                    &#125;                    i--;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第二次作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构体</tag>
      
      <tag>链表</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通讯录整理</title>
    <link href="/2020/03/14/%E9%80%9A%E8%AE%AF%E5%BD%95%E6%95%B4%E7%90%86/"/>
    <url>/2020/03/14/%E9%80%9A%E8%AE%AF%E5%BD%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="通讯录整理"><a class="markdownIt-Anchor" href="#通讯录整理"></a> 通讯录整理</h1><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>读取一组电话号码簿（由姓名和手机号码组成），将重复出现的项删除（姓名和电话号码都相同的项为重复项，只保留第一次出现的项），并对姓名相同手机号码不同的项进行如下整理：首次出现的项不作处理，第一次重复的姓名后面加英文下划线字符_和数字1，第二次重复的姓名后面加英文下划线字符_和数字2，依次类推。号码簿中姓名相同的项数最多不超过10个。最后对整理后的电话号码簿按照姓名进行从小到大排序，并输出排序后的电话号码簿。</p><h2 id="输入形式"><a class="markdownIt-Anchor" href="#输入形式"></a> 输入形式</h2><p>先从标准输入读取电话号码个数，然后分行输入姓名和电话号码，姓名由不超过20个英文小写字母组成，电话号码由11位数字字符组成，姓名和电话号码之间以一个空格分隔，输入的姓名和电话号码项不超过100个。</p><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>按照姓名从小到大的顺序分行输出最终的排序结果，先输出姓名再输出电话号码，以一个空格分隔。</p><h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2><p>15</p><p>liping 13512345678</p><p>zhaohong 13838929457</p><p>qiansan 13900223399</p><p>zhouhao 18578294857</p><p>anhai 13573948758</p><p>liping 13512345678</p><p>zhaohong 13588339922</p><p>liping 13833220099</p><p>boliang 15033778877</p><p>zhaohong 13838922222</p><p>tianyang 18987283746</p><p>sunnan 13599882764</p><p>zhaohong 13099228475</p><p>liushifeng 13874763899</p><p>caibiao 13923567890</p><h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2><p>anhai 13573948758</p><p>boliang 15033778877</p><p>caibiao 13923567890</p><p>liping 13512345678</p><p>liping_1 13833220099</p><p>liushifeng 13874763899</p><p>qiansan 13900223399</p><p>sunnan 13599882764</p><p>tianyang 18987283746</p><p>zhaohong 13838929457</p><p>zhaohong_1 13588339922</p><p>zhaohong_2 13838922222</p><p>zhaohong_3 13099228475</p><p>zhouhao 18578294857</p><h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2><p>输入了15个人名和电话号码。其中第一项和第六项完全相同，都是“liping 13512345678”，将第六项删除，第一项保留；</p><p>第八项和第一项人名相同，电话不同，则将第八项的人民整理为liping_1；同样，第二项、第七项、第十项、第十三项的人名都相同，将后面三项的人名分别整理为：zhaohong_1、zhaohong_2和zhaohong_3。</p><p>最后将整理后的电话簿按照姓名进行从小到大排序，分行输出排序结果。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM 100                                                     <span class="hljs-comment">//元素个数</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_list</span> &#123;</span>                                       <span class="hljs-comment">//定义结构体</span>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">21</span>];    <span class="hljs-keyword">char</span> num[<span class="hljs-number">12</span>];&#125; LIST;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process_repeat</span><span class="hljs-params">(LIST address[NUM],<span class="hljs-keyword">int</span> n)</span> </span>&#123;                       <span class="hljs-comment">//处理重复数据</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;    LIST tmp;    <span class="hljs-keyword">char</span> num[<span class="hljs-number">4</span>];    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(address[i].num, address[j].num) == <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">//先按照电话号码重复</span>                n--;                                                <span class="hljs-comment">//删除重复数据，避免</span>                <span class="hljs-keyword">for</span> (k = j; k &lt; n; k++) &#123;<span class="hljs-comment">//用姓名查找时2加角</span>                    address[k] = address[k + <span class="hljs-number">1</span>];<span class="hljs-comment">//标导致的错误</span>                &#125;                j--;            &#125;        &#125;        count = <span class="hljs-number">0</span>;                                                  <span class="hljs-comment">//每次要初始化计数</span>        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                               <span class="hljs-comment">//为姓名重复添加角标</span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(address[i].name, address[j].name) == <span class="hljs-number">0</span>) &#123;                count += <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123;                    <span class="hljs-built_in">strcpy</span>(num, <span class="hljs-string">"_10"</span>);                    <span class="hljs-built_in">strcat</span>(address[j].name, num);                &#125; <span class="hljs-keyword">else</span> &#123;                    num[<span class="hljs-number">0</span>] = <span class="hljs-string">'_'</span>;                    num[<span class="hljs-number">1</span>] = count + <span class="hljs-string">'0'</span>;                    num[<span class="hljs-number">2</span>] = <span class="hljs-string">'\0'</span>;                    <span class="hljs-built_in">strcat</span>(address[j].name, num);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> n;                                                       <span class="hljs-comment">//返回元素个数</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *p,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *q)</span> </span>&#123;                              <span class="hljs-comment">//qsort的比较函数</span>    <span class="hljs-keyword">int</span> c;    c = <span class="hljs-built_in">strcmp</span>((*(LIST *) p).name, (*(LIST *) q).name);             <span class="hljs-comment">//结构体快排的重点</span>    <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);    LIST address[NUM];    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s %s"</span>, address[i].name, address[i].num);    &#125;    n = process_repeat(address, n);                                 <span class="hljs-comment">//获取新的元素个数</span>    qsort(address, n, <span class="hljs-keyword">sizeof</span>(LIST), cmp);                           <span class="hljs-comment">//结构体快排</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %s\n"</span>, address[i].name, address[i].num);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第二次作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构体</tag>
      
      <tag>链表</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密文件</title>
    <link href="/2020/03/13/%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6/"/>
    <url>/2020/03/13/%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="加密文件"><a class="markdownIt-Anchor" href="#加密文件"></a> 加密文件</h1><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>有一种加密方法为：其使用一个字母串（可以含重复字母，字母个数不超过50）作为密钥。假定密钥单词串为feather，则先去掉密钥单词中的重复字母得到单词串feathr，然后再将字母表中的其它字母以反序追加到feathr的后面：</p><table><thead><tr><th>f</th><th>e</th><th>a</th><th>t</th><th>h</th><th>r</th><th>z</th><th style="text-align:left">y</th><th>x</th><th>w</th><th>v</th><th>u</th><th>s</th><th>q</th><th>p</th><th>o</th><th>n</th><th>m</th><th>l</th><th>k</th><th>j</th><th>i</th><th>g</th><th>d</th><th>c</th><th>b</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>加密字母的对应关系如下：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>k</th><th>l</th><th style="text-align:center">m</th><th>n</th><th>o</th><th>p</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>f</td><td>e</td><td>a</td><td>t</td><td>h</td><td>r</td><td>z</td><td>y</td><td>x</td><td>w</td><td>v</td><td>u</td><td style="text-align:center">s</td><td>q</td><td>p</td><td>o</td><td>n</td><td>m</td><td>l</td><td>k</td><td>j</td><td>i</td><td>g</td><td>d</td><td>c</td><td>b</td></tr></tbody></table><p>其中第一行为原始英文字母，第二行为对应加密字母。其它字符不进行加密。编写一个程序，用这种密码加密文件。假定要加密的文件名为encrypt.txt及加密后的文件名为output.txt，并假定输入文件中字母全为小写字母，并且输入密钥也全为小写字母。</p><h2 id="输入形式"><a class="markdownIt-Anchor" href="#输入形式"></a> 输入形式</h2><p>从标准输入中输入密钥串，并从文件encrypt.txt中读入要加密的内容。</p><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>加密后结果输出到文件output.txt中。</p><h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2><p>feather<br />和文件encrypt.txt中内容，例如被加密的文件encrypt.txt中内容为：<br />c language is wonderful.</p><h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2><p>加密后output.txt文件中内容为：<br />a ufqzjfzh xl gpqthmrju.</p><h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2><p>首先将给定的密钥单词去除重复字母，然后按照上面的加密对应表对encrypt.txt文件内容进行加密即可得到加密后的文件，其中只对英文字母进行加密对换，并且假设encrypt.txt中的英文字母全是小写字母。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> key[<span class="hljs-number">52</span>])</span></span>&#123;    <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">52</span>];    <span class="hljs-keyword">int</span> alphabet[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;, i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; key[k] != <span class="hljs-string">'\0'</span>; k++)&#123;        <span class="hljs-keyword">if</span>(alphabet[key[k]-<span class="hljs-string">'a'</span>] == <span class="hljs-number">0</span>)&#123;            alphabet[key[k]-<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>;            tmp[i++] = key[k];        &#125;    &#125;    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">25</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;        <span class="hljs-keyword">if</span>(alphabet[j] == <span class="hljs-number">0</span>)&#123;            alphabet[j] = <span class="hljs-number">1</span>;            tmp[i++] = j + <span class="hljs-string">'a'</span>;        &#125;    &#125;    tmp[i] = <span class="hljs-string">'\0'</span>;    <span class="hljs-built_in">strcpy</span>(key, tmp);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> key[<span class="hljs-number">52</span>], c[LEN];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    gets(key);    convert(key);    FILE *<span class="hljs-literal">INPUT</span>, *<span class="hljs-literal">OUTPUT</span>;    <span class="hljs-literal">INPUT</span> = fopen(<span class="hljs-string">"encrypt.txt"</span>,<span class="hljs-string">"r"</span>);    <span class="hljs-literal">OUTPUT</span> = fopen(<span class="hljs-string">"output.txt"</span>,<span class="hljs-string">"w"</span>);    <span class="hljs-keyword">while</span>(fgets(c, LEN, <span class="hljs-literal">INPUT</span>))&#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(c); i++)&#123;            <span class="hljs-keyword">if</span>(c[i] &gt;= <span class="hljs-string">'a'</span> &amp;&amp; c[i] &lt;= <span class="hljs-string">'z'</span>)&#123;                fputc(key[c[i]-<span class="hljs-string">'a'</span>], <span class="hljs-literal">OUTPUT</span>);            &#125;            <span class="hljs-keyword">else</span>&#123;                fputc(c[i], <span class="hljs-literal">OUTPUT</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第二次作业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串替换</title>
    <link href="/2020/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/"/>
    <url>/2020/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串替换新"><a class="markdownIt-Anchor" href="#字符串替换新"></a> 字符串替换（新）</h1><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>编写程序将一个指定文件中某一字符串替换为另一个字符串。要求：</p><ol><li>被替换字符串若有多个，均要被替换；</li><li>指定的被替换字 符串，大小写无关。</li></ol><h2 id="输入形式"><a class="markdownIt-Anchor" href="#输入形式"></a> 输入形式</h2><p>给定文件名为filein.txt。从控制台输入两行字符串（不含空格，行末尾都有回车换行符），分别表示被替换的字符串和替换字符串。</p><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>将替换后的结果输出到文件fileout.txt中。</p><h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2><p>从控制台输入两行字符串：</p><p>in</p><p>out</p><p>文件filein.txt的内容为：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  FILE * IN;  <span class="hljs-keyword">if</span>((IN=fopen(<span class="hljs-string">"in.txt"</span>,<span class="hljs-string">"r"</span>))==<span class="hljs-literal">NULL</span>)  &#123;​    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Can&amp;rsquo;t open in.txt!"</span>);​    <span class="hljs-keyword">return</span>;  &#125;  fclose(IN);&#125;</code></pre><h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2><p>文件fileout.txt的内容应为：</p><pre><code class="hljs c"><span class="hljs-meta">#outclude <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maout</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;  FILE * out;  <span class="hljs-keyword">if</span>((out=fopen(<span class="hljs-string">"out.txt"</span>,<span class="hljs-string">"r"</span>))==<span class="hljs-literal">NULL</span>)  &#123;​    prouttf(<span class="hljs-string">"Can&amp;rsquo;t open out.txt!"</span>);​    <span class="hljs-keyword">return</span>;  &#125;  fclose(out);&#125;</code></pre><h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2><p>输入的被替换字符串为in，替换字符串为out，即将文件filein.txt中的所有in字符串（包括iN、In、IN字符串）全部替换为out字符串，并输出保存到文件fileout.txt中。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 100</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">str_process</span><span class="hljs-params">(<span class="hljs-keyword">char</span> p[LEN], <span class="hljs-keyword">char</span> a[LEN], <span class="hljs-keyword">char</span> b[LEN])</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(a), i;    <span class="hljs-keyword">char</span> *q, r[LEN], s[LEN];    <span class="hljs-built_in">strcpy</span>(s, p);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(s); i++) &#123;        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'A'</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">'Z'</span>) &#123;            s[i] = s[i] + <span class="hljs-number">32</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span> ((q = <span class="hljs-built_in">strstr</span>(s, a)) != <span class="hljs-literal">NULL</span>) &#123;        p[q - s] = <span class="hljs-string">'\0'</span>;        <span class="hljs-built_in">strcpy</span>(r, p + (q - s) + len);        <span class="hljs-built_in">strcat</span>(p, b);        <span class="hljs-built_in">strcat</span>(p, r);        *q = <span class="hljs-string">'\0'</span>;        <span class="hljs-built_in">strcpy</span>(r, q + len);        <span class="hljs-built_in">strcat</span>(s, b);        <span class="hljs-built_in">strcat</span>(s, r);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> c[LEN], a[LEN], b[LEN];    gets(a);    gets(b);    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    FILE *IN, *OUT;    IN = fopen(<span class="hljs-string">"filein.txt"</span>, <span class="hljs-string">"r"</span>);    OUT = fopen(<span class="hljs-string">"fileout.txt"</span>, <span class="hljs-string">"w"</span>);    <span class="hljs-keyword">while</span> (fgets(c, LEN, IN)) &#123;        str_process(c, a, b);        <span class="hljs-built_in">fputs</span>(c, OUT);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第二次作业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>五子棋危险判断</title>
    <link href="/2020/03/12/%E4%BA%94%E5%AD%90%E6%A3%8B%E5%8D%B1%E9%99%A9%E5%88%A4%E6%96%AD/"/>
    <url>/2020/03/12/%E4%BA%94%E5%AD%90%E6%A3%8B%E5%8D%B1%E9%99%A9%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="五子棋危险判断"><a class="markdownIt-Anchor" href="#五子棋危险判断"></a> 五子棋危险判断</h1><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>已知两人分别执白棋和黑棋在一个围棋棋盘上下五子棋，若同一颜色的棋子在同一条横行、纵行或斜线上连成5个棋子，则执该颜色棋子的人获胜。编写程序读入某一时刻下棋的状态，并判断是否有人即将获胜，即：同一颜色的棋子在同一条横行、纵列或斜线上连成4个棋子，且该4个棋子的两端至少有一端为空位置。<br />输入的棋盘大小是19×19，用数字0表示空位置（即没有棋子），用数字1表示该位置下了一白色棋子，用数字2表示该位置下了一黑色棋子。假设同一颜色的棋子在同一条横行、纵列或斜线上连成的棋子个数不会超过4个，并且最多有一人连成线的棋子个数为4。</p><p>##输入形式</p><p>从控制台输入用来表示棋盘状态的数字0、1或2；每行输入19个数字，各数字之间以一个空格分隔，每行最后一个数字后没有空格；共输入19行表示棋盘状态的数字。</p><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>若有人即将获胜，则先输出即将获胜人的棋子颜色（1表示白色棋子，2表示黑色棋子），然后输出英文冒号:，最后输出连成4个棋子连线的起始位置（棋盘横行自上往下、纵列自左往右从1开始计数，横行最小的棋子在棋盘上的横行数和纵列数作为连线的起始位置，若在同一行上，则纵列数最小的棋子位置作为起始位置，两数字之间以一个英文逗号,作为分隔符）。<br />若没有人获胜，则输出英文字符串：No。<br />无论输出什么结果，最后都要有回车换行符。</p><h2 id="输入样例1"><a class="markdownIt-Anchor" href="#输入样例1"></a> 输入样例1</h2><p>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 2 0 1 1 2 0 0 0 0 0 0 0<br />0 0 0 0 0 2 1 1 1 1 2 2 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 1 2 1 2 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 1 1 0 2 2 0 0 0 0 0 0 0 0<br />0 0 0 0 0 2 0 1 0 0 2 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</p><h2 id="输出样例1"><a class="markdownIt-Anchor" href="#输出样例1"></a> 输出样例1</h2><p>1:9,8</p><h2 id="输入样例2"><a class="markdownIt-Anchor" href="#输入样例2"></a> 输入样例2</h2><p>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</p><h2 id="输出样例2"><a class="markdownIt-Anchor" href="#输出样例2"></a> 输出样例2</h2><p>No</p><h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2><p>在输入的样例1中，执白棋（数字1表示）的人即将获胜，连成4个棋子且有一端为空的起始位置在第9行第8列，所以输出1:9,8。<br />在输入的样例2中，还没有同一颜色的棋子连成4个，所以无人即将获胜，直接输出No。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre><code class="hljs c"><span class="hljs-comment">//此题并不严谨，仅考虑了四种同色相邻且一段为空的情况</span><span class="hljs-comment">//此题中每种情况的后三列/排可以不用考虑，可以在某种程度下简化算法</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//已知五子棋为19*19，但存在判断两端端点情况，故多加两行两列作为边框</span>    <span class="hljs-keyword">int</span> chess[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,n=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">20</span>;j++)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;chess[i][j]);        &#125;    &#125;    <span class="hljs-comment">//将边框初始化为'5'</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;i++)&#123;        chess[i][<span class="hljs-number">1</span>]=<span class="hljs-number">5</span>;        chess[i][<span class="hljs-number">20</span>]=<span class="hljs-number">5</span>;        chess[<span class="hljs-number">1</span>][i]=<span class="hljs-number">5</span>;        chess[<span class="hljs-number">20</span>][i]=<span class="hljs-number">5</span>;    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">17</span>;i++)&#123;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">17</span>;j++)&#123;            <span class="hljs-keyword">if</span>(chess[i][j]!=<span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">//判断纵向相连↓</span>                <span class="hljs-keyword">if</span>(chess[i][j]==chess[i+<span class="hljs-number">1</span>][j]&amp;&amp;chess[i][j]==chess[i+<span class="hljs-number">2</span>][j]&amp;&amp;chess[i][j]==chess[i+<span class="hljs-number">3</span>][j])&#123;                    <span class="hljs-keyword">if</span>(chess[i<span class="hljs-number">-1</span>][j]==<span class="hljs-number">0</span>||chess[i+<span class="hljs-number">4</span>][j]==<span class="hljs-number">0</span>)&#123;                        n++;                        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:%d,%d"</span>,chess[i][j],i,j);                        &#125;                    &#125;                &#125;    <span class="hljs-comment">//判断横向相连→</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chess[i][j]==chess[i][j+<span class="hljs-number">1</span>]&amp;&amp;chess[i][j]==chess[i][j+<span class="hljs-number">2</span>]&amp;&amp;chess[i][j]==chess[i][j+<span class="hljs-number">3</span>])&#123;                    <span class="hljs-keyword">if</span>(chess[i][j<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>||chess[i][j+<span class="hljs-number">4</span>]==<span class="hljs-number">0</span>)&#123;                        n++;                        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:%d,%d"</span>,chess[i][j],i,j);                        &#125;                    &#125;                &#125;    <span class="hljs-comment">//判断从左上至右下相连↘</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chess[i][j]==chess[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]&amp;&amp;chess[i][j]==chess[i+<span class="hljs-number">2</span>][j+<span class="hljs-number">2</span>]&amp;&amp;chess[i][j]==chess[i+<span class="hljs-number">3</span>][j+<span class="hljs-number">3</span>])&#123;                    <span class="hljs-keyword">if</span>(chess[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>||chess[i+<span class="hljs-number">4</span>][j+<span class="hljs-number">4</span>]==<span class="hljs-number">0</span>)&#123;                        n++;                        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:%d,%d"</span>,chess[i][j],i,j);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//判断右上至左下相连↙，因方向与其他不同，故重新循环</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">17</span>;i++)&#123;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">19</span>;j&gt;<span class="hljs-number">3</span>;j--)&#123;            <span class="hljs-keyword">if</span>(chess[i][j]!=<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(chess[i][j]==chess[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]&amp;&amp;chess[i][j]==chess[i+<span class="hljs-number">2</span>][j<span class="hljs-number">-2</span>]&amp;&amp;chess[i][j]==chess[i+<span class="hljs-number">3</span>][j<span class="hljs-number">-3</span>])&#123;                    <span class="hljs-keyword">if</span>(chess[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>||chess[i+<span class="hljs-number">4</span>][j<span class="hljs-number">-4</span>]==<span class="hljs-number">0</span>)&#123;                        n++;                        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:%d,%d"</span>,chess[i][j],i,j);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第二次作业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>表达式计算</title>
    <link href="/2020/03/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/03/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式计算支持空格连乘连除"><a class="markdownIt-Anchor" href="#表达式计算支持空格连乘连除"></a> 表达式计算（支持空格，连乘，连除）</h1><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>从标准输入中读入一个整数算术运算表达式，如5 - 1 * 2 * 3 + 12 / 2 / 2  = 。计算表达式结果，并输出。</p><p>要求：</p><ol><li>表达式运算符只有+、-、*、/，表达式末尾的’=’字符表示表达式输入结束，表达式中可能会出现空格；</li><li>表达式中不含圆括号，不会出现错误的表达式；</li><li>出现除号/时，以整数相除进行运算，结果仍为整数，例如：5/3结果应为1。</li></ol><h2 id="输入形式"><a class="markdownIt-Anchor" href="#输入形式"></a> 输入形式</h2><p>在控制台中输入一个以’=’结尾的整数算术运算表达式。</p><h2 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h2><p>向控制台输出计算结果（为整数）。</p><h2 id="样例1输入"><a class="markdownIt-Anchor" href="#样例1输入"></a> 样例1输入</h2><p>5 - 1 * 2 * 3 + 12 / 2 / 2  =</p><h2 id="样例1输出"><a class="markdownIt-Anchor" href="#样例1输出"></a> 样例1输出</h2><p>2</p><h2 id="样例2输入"><a class="markdownIt-Anchor" href="#样例2输入"></a> 样例2输入</h2><p>500 =</p><h2 id="样例2输出"><a class="markdownIt-Anchor" href="#样例2输出"></a> 样例2输出</h2><p>500</p><h2 id="样例1说明"><a class="markdownIt-Anchor" href="#样例1说明"></a> 样例1说明</h2><p>输入的表达式为5 - 1 * 2 * 3 + 12 / 2 / 2 =，按照整数运算规则，计算结果为2，故输出2。</p><h2 id="样例2说明"><a class="markdownIt-Anchor" href="#样例2说明"></a> 样例2说明</h2><p>输入的表达式为500 = ，没有运算符参与运算，故直接输出500。</p><p>算法之一提示：</p><ol><li>可以利用gets函数，读取整行表达式；</li><li>对于空格，可以考虑首先去除表达式中的所有空格</li><li>可以设一计数器用来记录已读取、但未参加运算的运算符的个数，根据该计数器来判断如何进行运算；</li><li>可以设计一函数：实现二元整数算术运算。</li></ol><h2 id="代码不完美"><a class="markdownIt-Anchor" href="#代码不完美"></a> 代码（不完美）</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_space</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">strlen</span>(p);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (p[i] == <span class="hljs-string">' '</span>) &#123;        p[i] = <span class="hljs-string">'\0'</span>;        <span class="hljs-built_in">strcat</span>(p, p + i + <span class="hljs-number">1</span>);        i -= <span class="hljs-number">1</span>;        len -= <span class="hljs-number">1</span>;    &#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> str[<span class="hljs-number">10000</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> num[<span class="hljs-number">10000</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag[<span class="hljs-number">10000</span>] = &#123;<span class="hljs-number">0</span>&#125;;    gets(str);    delete_space(str);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (str[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">'9'</span>) &#123;            num[i] = str[i] - <span class="hljs-string">'0'</span>;            flag[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (flag[i] == <span class="hljs-number">1</span> &amp;&amp; flag[i + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;            flag[i] = <span class="hljs-number">0</span>;            num[i + <span class="hljs-number">1</span>] = num[i] * <span class="hljs-number">10</span> + num[i + <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'*'</span> || str[i] == <span class="hljs-string">'/'</span>) &#123;            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'*'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] * num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'/'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] / num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'+'</span> || str[i] == <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'+'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] + num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'-'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] - num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; flag[i] == <span class="hljs-number">0</span>; i++);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, num[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="错误原因"><a class="markdownIt-Anchor" href="#错误原因"></a> 错误原因</h2><ol><li><p>SIGFPE<br />错误原因可能是:<br />零作为除数</p></li><li><p>SIGSEGV<br />错误原因可能是:<br />非法的内存引用, 具体原因可能是:<br />1.数组越界使用;<br />2.指针的错误使用, 一般是对非用户区的地址空间进行读或者写操作;<br />3.越权操作文件指针, 程序中却未捕捉该类错误;<br />4.栈溢出, 一般是因为过多的递归调用或者过大的临时变量导致;<br />5.程序使用的内存超过了题目设定的上限。</p></li></ol><h2 id="可能出错原因"><a class="markdownIt-Anchor" href="#可能出错原因"></a> 可能出错原因</h2><ol><li>删除空格函数<code>delete_space</code>有问题</li><li>函数中<code>strcat()</code>函数在评测机和本地跑出来的效果稍有不同</li></ol><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>改写<code>delete_space</code>函数</p><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_space</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">char</span> *<span class="hljs-built_in">begin</span> = str;    <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">begin</span> &amp;&amp; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) *<span class="hljs-built_in">begin</span> &lt;= <span class="hljs-number">32</span>) <span class="hljs-built_in">begin</span>++;    <span class="hljs-keyword">if</span> (!*<span class="hljs-built_in">begin</span>) &#123;        *str = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">while</span> (*str++ = *<span class="hljs-built_in">begin</span>++);    str -= <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) *str-- &lt;= <span class="hljs-number">32</span>);    *(str + <span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">10000</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> num[<span class="hljs-number">10000</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag[<span class="hljs-number">10000</span>] = &#123;<span class="hljs-number">0</span>&#125;;    gets(str);    delete_space(str);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (str[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">'9'</span>) &#123;            num[i] = str[i] - <span class="hljs-string">'0'</span>;            flag[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (flag[i] == <span class="hljs-number">1</span> &amp;&amp; flag[i + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;            flag[i] = <span class="hljs-number">0</span>;            num[i + <span class="hljs-number">1</span>] = num[i] * <span class="hljs-number">10</span> + num[i + <span class="hljs-number">1</span>];        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'*'</span> || str[i] == <span class="hljs-string">'/'</span>) &#123;            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'*'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] * num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'/'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] / num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++) &#123;        <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'+'</span> || str[i] == <span class="hljs-string">'-'</span>) &#123;            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'+'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] + num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">'-'</span>) &#123;                str[i] = <span class="hljs-string">'#'</span>;                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; flag[j] == <span class="hljs-number">0</span>; j--);                <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; flag[k] == <span class="hljs-number">0</span>; k++);                num[j] = num[j] - num[k];                flag[k] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; flag[i] == <span class="hljs-number">0</span>; i++);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, num[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第一次作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
